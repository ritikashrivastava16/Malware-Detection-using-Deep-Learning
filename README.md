# Malware Detection using Deep Learning

## tl;dr
1) Collected benign and malicious executable (.exe) files from different sources
2) Disassembled executable files into assembly (.asm) language files
3) Extracted opcode sequences from .asm files using a Python script (extract_malware.py, extract_benign.py)
4) Cleaned and pre-processed the opcode sequences (curate_dataset.py)
5) Split the data into train and test set
6) Fit a tokenizer to the training data and used the same tokenizer to transform test data to form tokenized opcode sequence matrix
7) Used Word Embedding technology to automatically obtain feature vector representation (much like NLP, this technology helps in understanding the semantic context of opcodes) 
8) Developed an LSTM model with 3 layers of 32 neurons each. Needed a sequence model to automatically learn opcode sequences to distinguish benign file from malicious file (chose this over RNN because RNN suffers from problem of exploding and vanishing gradients)
Added dropout layers to prevent overfitting. 
Used adam optimizer with 0.001 learning rate. 
9) Trained the model and tested it using the accuracy metric
10) Performed 10-fold cross validation to yield 95.01% (+/- 2.40%) accuracy
11) Compared output with various Machine Learning algorithms and Deep Learning Models

## Problem Statement
Detect the nature of an executable file based on the opcode sequences from its assembly language.

## Dataset
<p>Dataset contains 621 malware and 200 benign files. Malware files which are divided into 5 types: Locker, Mediyes , Winwebsec , Zbot , Zeroaccess. All malware files are collected from https://virusshare.com/ and malicia-project.com. Benign executable files are taken from installed folders of applications of legitimate software from different categories. They can be downloaded from https://download.cnet.com/windows/. All the files are verified by VirusTotal (https://www.virustotal.com) to make sure each file belongs to their type.</p>

## Data Preprocessing
The Data pre-processing component consists of creation of a labelled dataset. The executable files are fed to an online disassembler https://onlinedisassembler.com/odaweb/ . 
<br> This tool extracts the opcode from the executable file. The opcode file is saved. This opcode file serves as an input to the extraction algorithm which essentially selects only those parts of the opcode that determine the classification between a malicious file and a benign file. These opcodes are pre-determined.
<br>The sequence of the opcode is the most important feature of the extraction process which is as follows:
- To extract opcodes from the files, they need to be converted to assembly files using a third party online disassembly tool.
- These assembly files are then fed to the extraction script written in Python using a code parsing library PyParser.
- The extraction script identifies and appends the opcodes in a list for each file. The extracted opcodes are then saved in a csv file.
- These feature vectors, representing the executable files, will then be passed to the classification model section.
<br>A dataset is then created by labelling the benign sequence of opcode as ‘0’ and the malicious sequence of opcode as ‘1’. This dataset is saved as a ‘.csv’ file and fed to the prediction algorithm.

## Component Design
The Malware Detection Methodology proposed for this project can be divided into two sections/components:
1. Data Pre-processing Section
2. Classification Model Section

![image](https://user-images.githubusercontent.com/54627261/207671501-bdc54623-9c59-4d58-b002-e735204bd4d0.png)


## Classification Model
<br>The classification is done using a 3 Layer LSTM model. Initially the dataframe is divided into two variables namely X and y. The X input variable contains the sequence of opcodes and the y input variable contains the opcode label (0 or 1). The X and y variables are split into train and test sets as 90% and 10% of the dataset respectively.
<br>The Tokenizer is used to label all the unique opcodes that are present in different file sequences. It is used to vectorize a text corpus, by turning each text into either a sequence of integers. This encoded sequence replaces the actual opcode with a number designated to that particular code by the Tokenizer.
<br>We have limited the number of words in the corpus to 1000 and are using 54580 as the length of each opcode sequence since it lies at the 90th percentile of the data. By using the 90th percentile, we are capturing maximum information without adding extra computational costs.

![image](https://user-images.githubusercontent.com/54627261/207663121-ce337d8b-541e-4aa6-948c-e6252c583054.png)

## Model Evaluation

![image](https://user-images.githubusercontent.com/54627261/207664573-abf28f0d-2bf4-4109-b6fd-05b50bdc887b.png)

![image](https://user-images.githubusercontent.com/54627261/207664644-2222885a-adc9-49ea-9ed2-afc470bfcc51.png)

- **10-fold CV: 95.01% (+/- 2.40%)**
- **5-fold CV: 95.62% (+/- 0.80%)**
<br>**These results validate the testing accuracy of 95% we have achieved from the 3 Layer LSTM Model.**

